/*** Snippets for iOS Application Part 1, BleService Skeleton ***/

/*** Timers_Snip_1 ***/

a)
fileprivate let scanTimeout             = TimeInterval(20.0)
fileprivate let connectAttemptTimeout   = TimeInterval(10.0)
fileprivate let connectionTimeout       = TimeInterval(10.0)

b)
private let eventTimer = EventTimer()

/*** End ***/

/*** Timers_Snip_2 ***/
/*** In performScan ***/

eventTimer.scheduleEvent(fromNow: scanTimeout,
                         onTimeout: {
                            os_log("Scan timed out", log: Log.ble, type: .info)
                            cm.stopScan()
                            self.cmdQueue.async {
                                self.handleEvent(event: .ScanTimeout)
                            }},
                         onCancel: nil)
cm.scanForPeripherals(withServices: [suuid], options: nil)

/*** End ***/


/*** Timers_Snip_3 ***/
/*** In didDiscoverPeripheral ***/

eventTimer.cancel()
central.stopScan()

/*** End ***/


/*** Timers_Snip_4 ***/
/*** In performRetrieve ***/

eventTimer.scheduleEvent(fromNow: connectAttemptTimeout,
                         onTimeout: {
                            os_log("Connect attempt timed out", log: Log.ble, type: .info)
                            cm.cancelPeripheralConnection(per)
                            },
                         onCancel: nil)
cm.connect(per, options: nil)

/*** End ***/

/*** Timers_Snip_5 ***/
/*** In performConnect ***/

eventTimer.scheduleEvent(fromNow: connectAttemptTimeout,
                         onTimeout: {
                            os_log("Connect attempt timed out", log: Log.ble, type: .info)
                            cm.cancelPeripheralConnection(per)
                            },
                         onCancel: nil)
cm.connect(per, options: nil)

/*** End ***/

/*** Timers_Snip_6 ***/
/*** In didConnect delegate callback ***/

a) Add new timeout
fileprivate let readRSSITimeout         = TimeInterval(0.5)

b) In didConnect callback
let timeout: TimeInterval
if case BleCommand.readRSSI = activeCommand.command { timeout = readRSSITimeout }
else { timeout = connectionTimeout }

eventTimer.scheduleEvent(fromNow: timeout,
                         onTimeout: {
                            os_log("Connection timed out", log: Log.ble, type: .info)
                            central.cancelPeripheralConnection(peripheral)
                            },
                         onCancel: nil)
let payload = PPayload(peripheral: peripheral)
cmdQueue.async { self.handleEvent(event: .ConnectSuccess(payload)) }

/*** End ***/

/*** Timers_Snip_7 ***/
/*** In Action Maps ***/

actionMap[.Scanning]?[.ScanTimeout] = (action: performNullAction, nextState: .Start)

actionMap[.Retrieving]?[.Disconnected] = (action: performNullAction, nextState: .Scanning)

actionMap[.Ready]?[.Disconnected] = (action: performNullAction, nextState: nil)

actionMap[.RWNotify]?[.Disconnected] = (action: performNullAction, nextState: .Ready)

actionMap[.ReadRSSI]?[.Disconnected] = (action: performNullAction, nextState: .Ready)

/*** End ***/
