/*** Snippets for iOS Application Part 1, Writing Characteristics - BleService ***/

/*** Writing_Characs_Ble_Snip_1 ***/

//
// Valid states
//
enum BState: Int, CaseIterable {
    case Start
    case Scanning
    case Retrieving
    case Ready
    case RWNotify
    case ReadRSSI
}

extension BState: CustomStringConvertible {

    var description: String {
        switch self {
        case .Start: return "Start"
        case .Scanning: return "Scanning"
        case .Retrieving: return "Retrieving"
        case .Ready: return "Ready"
        case .RWNotify: return "RWNotify"
        case .ReadRSSI: return "ReadRSSI"
        }
    }
}

//
// Valid events
//
enum BEvent {
    case OnLine             // Bluetooth is powered on and available
    case OffLine            // Bluetooth is not available (several possible reasons)
    case Retrieve
    case RetrieveFail
    case Scan
    case ScanSuccess
    case ScanCancelled
    case ScanTimeout
    case ConnectSuccess(peripheral: CBPeripheral?)
    case ConnectFail
    case ConnectAttemptTimeout
    case ConnectionTimeout
    case Disconnected
    case DisconnectedWithError
    case Read
    case Write
    case SetNotify
    case ReadRSSI
    case DiscoverServices
    case DiscoverServicesSuccess((peripheral: CBPeripheral, service: CBService)?)
    case DiscoverServicesFail
    case DiscoverCharacteristics
    case DiscoverCharacteristicsSuccess((peripheral: CBPeripheral, service: CBService, charac: CBCharacteristic)?)
    case DiscoverCharacteristicsFail

}

extension BEvent: Hashable {
    static func == (lhs: BEvent, rhs: BEvent) -> Bool {
        return lhs.hashValue == rhs.hashValue ? true : false
    }

    func hash(into hasher: inout Hasher) {

        switch self {
        case .OnLine: hasher.combine(0)
        case .OffLine: hasher.combine(1)
        case .Retrieve: hasher.combine(2)
        case .RetrieveFail: hasher.combine(3)
        case .Scan: hasher.combine(4)
        case .ScanSuccess: hasher.combine(5)
        case .ScanCancelled: hasher.combine(6)
        case .ScanTimeout: hasher.combine(7)
        case .ConnectSuccess: hasher.combine(8)
        case .ConnectFail: hasher.combine(9)
        case .ConnectAttemptTimeout: hasher.combine(10)
        case .ConnectionTimeout: hasher.combine(11)
        case .Disconnected: hasher.combine(12)
        case .DisconnectedWithError: hasher.combine(13)
        case .Read: hasher.combine(14)
        case .Write: hasher.combine(15)
        case .SetNotify: hasher.combine(16)
        case .ReadRSSI: hasher.combine(17)
        case .DiscoverServices: hasher.combine(18)
        case .DiscoverServicesSuccess: hasher.combine(19)
        case .DiscoverServicesFail: hasher.combine(20)
        case .DiscoverCharacteristics: hasher.combine(21)
        case .DiscoverCharacteristicsSuccess: hasher.combine(22)
        case .DiscoverCharacteristicsFail: hasher.combine(23)
        }
    }
}

extension BEvent: CustomStringConvertible {
    
    var description: String {
        switch self {
            case .OnLine: return "OnLine"
            case .OffLine: return "OffLine"
            case .Retrieve: return "Retrieve"
            case .RetrieveFail: return "RetrieveFail"
            case .Scan: return "Scan"
            case .ScanSuccess: return "ScanSuccess"
            case .ScanCancelled: return "ScanCancelled"
            case .ScanTimeout: return "Scan Timeout"
            case .ConnectSuccess: return "Connect Success"
            case .ConnectFail: return "Connect Fail"
            case .ConnectAttemptTimeout: return "Connect Attempt Timeout"
            case .ConnectionTimeout: return "Connection Timeout"
            case .Disconnected: return "Disconnected"
            case .DisconnectedWithError: return "Disconnected With Error"
            case .Read: return "Read"
            case .Write: return "Write"
            case .SetNotify: return "Set Notify"
            case .ReadRSSI: return "Read RSSI"
            case .DiscoverServices: return "Discover Services"
            case .DiscoverServicesSuccess: return "Discover Services Success"
            case .DiscoverServicesFail: return "Discover Services Fail"
            case .DiscoverCharacteristics: return "Discover Characteristics"
            case .DiscoverCharacteristicsSuccess: return "Discover Characteristics Success"
            case .DiscoverCharacteristicsFail: return "Discover Characteristics Fail"
        }
    }
}

/*** End ***/

/*** Writing_Characs_Ble_Snip_2 ***/
/*** Modify - add associated value ***/
actionMap[.Retrieving]?[.ConnectSuccess(nil)] = (action: performNullAction, nextState: .Ready)

/*** Ready state: Add ***/
actionMap[.Ready]?[.Write] = (action: performConnect, nextState: .RWNotify)

/*** RWNotify state: Add ***/
//
actionMap[.RWNotify]?[.ConnectSuccess(nil)] = (action: performDiscoverServices, nextState: nil)
actionMap[.RWNotify]?[.ConnectFail] = (action: performNullAction, nextState: .Ready)
actionMap[.RWNotify]?[.DiscoverServicesSuccess(nil)] = (action: performDiscoverCharacteristics, nextState: nil)
actionMap[.RWNotify]?[.DiscoverServicesFail] = (action: performNullAction, nextState: .Ready)
actionMap[.RWNotify]?[.DiscoverCharacteristicsSuccess(nil)] = (action: performCommand, nextState: .Ready)
actionMap[.RWNotify]?[.DiscoverCharacteristicsFail] = (action: performNullAction, nextState: .Ready)
actionMap[.RWNotify]?[.DisconnectedWithError] = (action: performNullAction, nextState: .Ready)
actionMap[.RWNotify]?[.OffLine] = (action: performNullAction, nextState: .Start)

/*** Error map: Add ***/
errorMap[.Start] = (action: performNullAction, nextState: .Start)
errorMap[.Ready] = (action: performNullAction, nextState: .Ready)
errorMap[.RWNotify] = (action: performNullAction, nextState: .Ready)
errorMap[.ReadRSSI] = (action: performNullAction, nextState: .Ready)

/*** End ***/

/*** Writing_Characs_Ble_Snip_3 ***/

case InvalidPayload

case .InvalidPayload: return "Invalid enum payload"

/*** End ***/

/*** Writing_Characs_Ble_Snip_4 ***/

a) Add at file scope level
//
// Ble Commands
fileprivate enum BleCommand {
    case read
    case write(Data, CBCharacteristicWriteType)
    case setNotify(Bool)
    case readRSSI
}

fileprivate struct ActiveCommand {
    var suuid: CBUUID?
    var cuuid: CBUUID?
    var command: BleCommand = .read
}

b) Add to properties
private var activeCommand = ActiveCommand()

/*** End ***/

/*** Writing_Characs_Ble_Snip_5 ***/

activeCommand = ActiveCommand(suuid: service,
                              cuuid: charac,
                              command: .write(data, response == true ? .withResponse : .withoutResponse))
cmdQueue.async { self.handleEvent(event: .Write) }

/*** End ***/

/*** Writing_Characs_Ble_Snip_6 ***/
/*** Modify didConnect ***/

let payload = PPayload(peripheral: peripheral)
cmdQueue.async { self.handleEvent(event: .ConnectSuccess(payload)) }

/*** End ***/

/*** Writing_Characs_Ble_Snip_7 ***/

func performDiscoverServices(thisEvent: BEvent, thisState: BState) throws {
    os_log("In performDiscoverServices, event: %s state %s", log: Log.ble, type: .info, thisEvent.description, thisState.description)
    guard case BEvent.ConnectSuccess(let payload) = thisEvent, let pl = payload else {
        throw BleError.InvalidPayload }
    guard let suuid = activeCommand.suuid else {
        throw BleError.UninitialisedProperty }
    
    pl.peripheral.discoverServices([suuid])
}

/*** End ***/

/*** Writing_Characs_Ble_Snip_8 ***/

func performDiscoverCharacteristics(thisEvent: BEvent, thisState: BState) throws {
    os_log("In performDiscoverCharacteristics, event: %s state %s", log: Log.ble, type: .info, thisEvent.description, thisState.description)
    guard case BEvent.DiscoverServicesSuccess(let payload) = thisEvent, let pl = payload else {
        throw BleError.InvalidPayload }
    guard let cuuid = activeCommand.cuuid else {
        throw BleError.UninitialisedProperty }
    
    pl.peripheral.discoverCharacteristics([cuuid], for: pl.service)
}

/*** End ***/

/*** Writing_Characs_Ble_Snip_9 ***/

func peripheral(_ peripheral: CBPeripheral, didDiscoverCharacteristicsFor service: CBService, error: Error?) {
    guard error == nil,
        let cuuid = activeCommand.cuuid,
        let characs = service.characteristics,
        let thisCharac = (characs.filter { $0.uuid == cuuid }).first else {
            cmdQueue.async { self.handleEvent(event: .DiscoverCharacteristicsFail) }
            return }
    
    let payload = (peripheral: peripheral, service: service, charac: thisCharac)
    cmdQueue.async { self.handleEvent(event: .DiscoverCharacteristicsSuccess(payload)) }
}

/*** End ***/

/*** Writing_Characs_Ble_Snip_10 ***/

func performCommand(thisEvent: BEvent, thisState: BState) throws {
    os_log("In performCommand, event: %s state %s", log: Log.ble, type: .info, thisEvent.description, thisState.description)
    guard case BEvent.DiscoverCharacteristicsSuccess(let payload) = thisEvent, let pl = payload else {
        throw BleError.InvalidPayload }
        
        switch activeCommand.command {
        case .write(let data, let type):
            pl.peripheral.writeValue(data, for: pl.charac, type: type)
        default:
            break       // Complete other cases later...
        }
}

/*** End ***/

/*** Writing_Characs_Ble_Snip_11 ***/
/*** Modify performNotifyAttached

func performNotifyAttached(event: BEvent, state: BState) {
    os_log("In performNotifyAttached, event: %s state: %s", log: Log.ble, type: .info, event.description, state.description)

    if attachingWith.isAttached == false {
        attachingWith.isAttached = true
        if let per = attachingWith.peripheral, let suuid = attachingWith.service {
            setLastAttachedPeripheral(defaults: ud, peripheral: per, service: suuid)
        }
        nc.post(name: .bleStatus, object: BleStatusPayload(status: .ready))
    }
    else {
        // Complete later...
    }
}

/*** End ***/

