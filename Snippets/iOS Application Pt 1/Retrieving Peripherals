/*** Snippets for iOS Application Part 1, Retrieving Peripherals ***/

/*** Retrieving_Peripherals_Snip_1 ***/
/*** Add to properties ***/

// Last attached peripheral
private struct LastAttachedPeripheral: Codable {
    var peripheral: UUID
    var serviceData: Data
}
private let kLastAttachedPeripheralKey = "lap"
private var ud: UserDefaults

/*** End ***/

/*** Retrieving_Peripherals_Snip_2 ***/

init(defaults: UserDefaults = UserDefaults.standard) {
    ud = defaults
    super.init()

/*** End ***/

/*** Retrieving_Peripherals_Snip_3 ***/

private func setLastAttachedPeripheral(defaults: UserDefaults, peripheral: CBPeripheral, service: CBUUID) {
    let last = LastAttachedPeripheral(peripheral: peripheral.identifier, serviceData: service.data)
    defaults.set(try? JSONEncoder().encode(last), forKey: kLastAttachedPeripheralKey)
}

private func getLastAttachedPeripheral(defaults: UserDefaults) -> LastAttachedPeripheral? {
    var retValue: LastAttachedPeripheral? = nil
    if let lapData = defaults.object(forKey: kLastAttachedPeripheralKey) as? Data {
        retValue = try? JSONDecoder().decode(LastAttachedPeripheral.self, from: lapData)
    }
    return retValue
}

/*** End ***/

/*** Retrieving_Peripherals_Snip_4 ***/
/*** Add new states and events ***/

a) States
case Retrieving
...
case .Retrieving: return "Retrieving"

b) Events
case Retrieve
case RetrieveFail
case ConnectSuccess
case ConnectFail
case Disconnected
case DisconnectedWithError
...
case .Retrieve: return "Retrieve"
case .RetrieveFail: return "RetrieveFail"
case .ConnectSuccess: return "Connect Success"
case .ConnectFail: return "Connect Fail"
case .Disconnected: return "Disconnected"
case .DisconnectedWithError: return "Disconnected With Error"

/*** End ***/

/*** Retrieving_Peripherals_Snip_5 ***/
/*** Modify function signature and queueing statement ***/

func attachPeripheral(service: CBUUID, forceScan: Bool = false) {
    
    attachingWith = (nil, service, false)
    cmdQueue.async { self.handleEvent(event: forceScan ? .Scan : .Retrieve) }
}

/*** End ***/

/*** Retrieving_Peripherals_Snip_6 ***/

func performRetrieve(event: BEvent, state: BState) throws {
    os_log("In performRetrieve, event: %s state %s", log: Log.ble, type: .info, event.description, state.description)
    guard let cm = centralManager, let suuid = attachingWith.service else {
        throw BleError.UninitialisedProperty }

}

func performRetrieve(event: BEvent, state: BState) throws {
    os_log("In performRetrieve, event: %s state %s", log: Log.ble, type: .info, event.description, state.description)
    guard let cm = centralManager, let suuid = attachingWith.service else {
        throw BleError.UninitialisedProperty }

    if let lap = getLastAttachedPeripheral(defaults: ud), CBUUID(data: lap.serviceData) == suuid {
        os_log("Retrieving...", log: Log.ble, type: .info)
        if let per = cm.retrievePeripherals(withIdentifiers: [lap.peripheral]).first {
            per.delegate = self
            attachingWith.peripheral = per
            cm.connect(per, options: nil)
        }
        else {
            cmdQueue.async { self.handleEvent(event: .RetrieveFail) }
        }
    }
    else {
        cmdQueue.async { self.handleEvent(event: .RetrieveFail) }
    }
}

/*** End ***/

/*** Retrieving_Peripherals_Snip_7 ***/
/*** Modify performNotifyAttached ***/

attachingWith.isAttached = true
if let per = attachingWith.peripheral, let suuid = attachingWith.service {
    setLastAttachedPeripheral(defaults: ud, peripheral: per, service: suuid)
}
nc.post(name: .bleStatus, object: BleStatusPayload(status: .ready))

/*** End ***/

/*** Retrieving_Peripherals_Snip_8 ***/

func centralManager(_ central: CBCentralManager, didConnect peripheral: CBPeripheral) {
    os_log("In didConnect: %s", log: Log.ble, type: .info, peripheral.identifier.uuidString)

    cmdQueue.async { self.handleEvent(event: .ConnectSuccess) }
    
}

func centralManager(_ central: CBCentralManager, didFailToConnect peripheral: CBPeripheral, error: Error?) {
    os_log("In didFailToConnect: %s", log: Log.ble, type: .info, peripheral.identifier.uuidString)

    cmdQueue.async { self.handleEvent(event: .ConnectFail) }
    
}

func centralManager(_ central: CBCentralManager, didDisconnectPeripheral peripheral: CBPeripheral, error: Error?) {
    os_log("In didFailToConnect: %s", log: Log.ble, type: .info, peripheral.identifier.uuidString)
    
    if error == nil {
        // Intentional disconnect
        cmdQueue.async { self.handleEvent(event: .Disconnected) }
    }
    else {
        // Unexpected disconnect
        os_log("Peripheral disconnected with error", log: Log.ble, type: .error)
        cmdQueue.async { self.handleEvent(event: .DisconnectedWithError) }
    }
    
}

/*** End ***/

/*** Retrieving_Peripherals_Snip_9 ***/

if let per = attachingWith.peripheral, let suuid = attachingWith.service {
    setLastAttachedPeripheral(defaults: ud, peripheral: per, service: suuid)
}
**/

/*** Retrieving_Peripherals_Snip_10 ***/
/*** Changes to action maps ***/

/*** Add state action map entry ***/
stateActionMap[.Retrieving] = (onEntry: performRetrieve, onExit: nil)

/*** Change Start/OffLine to Start/Scan; add Start/Retrieve ***/

actionMap[.Start]?[.Scan] = (action: performNullAction, nextState: .Scanning)
actionMap[.Start]?[.Retrieve] = (action: performNullAction, nextState: .Retrieving)

/*** Add Retrieving state entries: ***/

actionMap[.Retrieving]?[.RetrieveFail] = (action: performNullAction, nextState: .Scanning)
actionMap[.Retrieving]?[.ConnectSuccess] = (action: performNullAction, nextState: .Ready)
actionMap[.Retrieving]?[.ConnectFail] = (action: performNullAction, nextState: .Start)
actionMap[.Retrieving]?[.OffLine] = (action: performNullAction, nextState: .Start)

/*** Add to Ready state: ***/

actionMap[.Ready]?[.Disconnected] = (action: performNullAction, nextState: nil)
actionMap[.Ready]?[.DisconnectedWithError] = (action: performNullAction, nextState: nil)

/*** End ***/
